name: "Build and Push"

inputs:
  VERSION_MAJOR:
    required: true
  DATE_STAMP:
    required: true
  IMAGE_REGISTRY:
    required: true
  REGISTRY_USER:
    required: false  # Changed to false for ttl.sh compatibility
  REGISTRY_PASSWORD:
    required: false  # Changed to false for ttl.sh compatibility
  AWS_ROLE_ARN:
    description: 'AWS IAM role ARN for KMS signing'
    required: true
  AWS_REGION:
    description: 'AWS region where KMS key is located'
    required: true
    default: 'us-east-1'
  KMS_KEY_ID:
    description: 'KMS key ID or alias for signing'
    required: true
    default: 'SIG_Atomic_Container_Signing_GH_CI'
  # Legacy support - if provided, will use keyless signing instead of KMS
  SIGNING_SECRET:
    required: false
  GITHUB_TOKEN:
    description: 'GitHub token for GHCR authentication'
    required: false

runs:
  using: "composite"
  steps:
    - name: Prepare environment
      shell: bash
      run: |
        [[ "${{ env.PLATFORM }}" = */v2 ]] && VARIANT="--variant v2"
        echo "VARIANT=--platform ${{ env.PLATFORM }} ${VARIANT}" >> "$GITHUB_ENV"

        # Handle different registry destinations
        if [[ "${{ inputs.IMAGE_REGISTRY }}" == "ghcr.io" ]]; then
          # GHCR format: ghcr.io/username/repo/imagename
          IMAGE_DEST=ghcr.io/${{ github.repository_owner }}/${{ github.event.repository.name }}/${{ env.IMAGE_NAME }}
        else
          # Standard registry format: registry.com/org/imagename
          IMAGE_DEST=${{ inputs.IMAGE_REGISTRY }}/${{ env.IMAGE_NAME }}
        fi
        echo "IMAGE_DEST=${IMAGE_DEST}" >> "$GITHUB_ENV"

        ARCH=${{ matrix.ARCH }}
        echo "CLEAN_ARCH=${ARCH//\//_}" >> "$GITHUB_ENV"

    - name: Log in to registry
      if: ${{ env.res != 0 || github.event_name == 'workflow_dispatch' }}
      shell: bash
      run: |
        # Login to registry (all registries require authentication)
        if [[ "${{ inputs.IMAGE_REGISTRY }}" == "ghcr.io" ]]; then
          # For GHCR (forks), use GitHub token directly to avoid masking issues
          echo "${{ inputs.GITHUB_TOKEN }}" | sudo podman login ${{ inputs.IMAGE_REGISTRY }} -u ${{ inputs.REGISTRY_USER }} --password-stdin
        else
          # For production registries, use the provided password
          echo "${{ inputs.REGISTRY_PASSWORD }}" | sudo podman login ${{ inputs.IMAGE_REGISTRY }} -u ${{ inputs.REGISTRY_USER }} --password-stdin
        fi

    - name: Check update
      shell: bash
      run: |
        # 'dnf check-update'
        # exit codes:
        #   0 - no updates
        #   100 - updates available
        #   125 - tag/platform not found
        #   127 - command not found
        res=0
        sudo podman run ${{ env.VARIANT }} --quiet --rm ${{ inputs.IMAGE_REGISTRY }}/${{ env.IMAGE_NAME }}:${{ inputs.VERSION_MAJOR }} dnf check-update || res=$?
        echo "res=${res}" >> "$GITHUB_ENV"
        echo "Exit code: '$res'"

    - name: Get info
      id: info
      if: ${{ env.res != 0 || github.event_name == 'workflow_dispatch' }}
      shell: bash
      run: |
        INFO=$(sudo podman run ${{ env.VARIANT }} --quiet --rm quay.io/almalinuxorg/${{ inputs.VERSION_MAJOR }}-base bash -c "dnf upgrade -y almalinux-release && cat /etc/os-release" || true)
        echo "$INFO"

        echo "id=$(echo "$INFO" | grep "^ID=" | cut -d'=' -f2 | tr -d '"')" >> $GITHUB_OUTPUT
        echo "version-id=$(echo "$INFO" | grep "^VERSION_ID=" | cut -d'=' -f2 | tr -d '"')" >> $GITHUB_OUTPUT
        echo "long-version=$(echo "$INFO" | grep "^VERSION_ID=" | cut -d'=' -f2 | tr -d '"').${{ inputs.DATE_STAMP }}.0" >> $GITHUB_OUTPUT

    - name: Build image
      id: build
      if: ${{ env.res != 0 || github.event_name == 'workflow_dispatch' }}
      shell: bash
      run: |
        BUILD_TIME=$(date -Iseconds)

        # define a multiline variable with heredoc
        LABELS=$(cat <<EOF
        redhat.id=${{ steps.info.outputs.id }}
        redhat.version-id=${{ steps.info.outputs.version-id }}
        version=${{ steps.info.outputs.version-id }}
        release=${{ steps.info.outputs.version-id }}
        build-date=${BUILD_TIME}
        org.opencontainers.image.created=${BUILD_TIME}
        org.opencontainers.image.version=${{ steps.info.outputs.long-version }}
        org.opencontainers.image.source=${{ github.repositoryUrl }}
        org.opencontainers.image.title=${{ env.IMAGE_NAME }}
        org.opencontainers.image.url=${{ github.event.repository.html_url }}
        EOF
        )

        while IFS= read -r label; do
          ALL_LABELS="$ALL_LABELS --label=\"$label\" --annotation=\"$label\""
        done <<< "$LABELS"

        make image \
          PLATFORM=${{ env.PLATFORM }} \
          LABELS="${ALL_LABELS}" \
          IMAGE_NAME=${{ env.IMAGE_NAME }} \
          VERSION_MAJOR=${{ inputs.VERSION_MAJOR }}

        echo "image-id=$(cat /tmp/image-id)" >> $GITHUB_OUTPUT

    - name: rechunk image
      id: rechunk
      if: ${{ env.res != 0 || github.event_name == 'workflow_dispatch' }}
      shell: bash
      run: |
        make rechunk \
          PLATFORM=${{ env.PLATFORM }} \
          IMAGE_NAME=${{ env.IMAGE_NAME }}

        echo "image-id=sha256:$(sudo podman image inspect ${{ env.IMAGE_NAME }} -f "{{.Id}}")" >> $GITHUB_OUTPUT

    - name: Run Image
      id: run
      if: ${{ env.res != 0 || github.event_name == 'workflow_dispatch' }}
      shell: bash
      env:
        IMAGE_ID: ${{ steps.rechunk.outputs.image-id }}
      run: |
        sudo podman run ${{ env.VARIANT }} --rm -ti ${{ env.IMAGE_ID }} bootc --version

        INFO=$(sudo podman run ${{ env.VARIANT }} --rm ${{ env.IMAGE_ID }} cat /etc/os-release)
        echo "$INFO"

        echo "id=$(echo "$INFO" | grep "^ID=" | cut -d'=' -f2 | tr -d '"')" >> $GITHUB_OUTPUT
        echo "version-id=$(echo "$INFO" | grep "^VERSION_ID=" | cut -d'=' -f2 | tr -d '"')" >> $GITHUB_OUTPUT
        echo "long-version=$(echo "$INFO" | grep "^VERSION_ID=" | cut -d'=' -f2 | tr -d '"').${{ inputs.DATE_STAMP }}.0" >> $GITHUB_OUTPUT
        echo "vendor=$(echo "$INFO" | grep "^VENDOR_NAME=" | cut -d'=' -f2 | tr -d '"')" >> $GITHUB_OUTPUT

    - name: Push to registry
      id: push
      if: ${{ env.res != 0 || github.event_name == 'workflow_dispatch' }}
      env:
        IMAGE_ID: ${{ steps.rechunk.outputs.image-id }}
        VERSION: ${{ steps.run.outputs.version-id }}
      shell: bash
      run: |
        sudo podman push --digestfile=/tmp/digestfile ${{ env.IMAGE_ID }} \
          docker://${IMAGE_DEST}:${{ env.VERSION }}-${{ inputs.DATE_STAMP }}-${{ env.CLEAN_ARCH }}

        echo "digest=$(cat /tmp/digestfile)" >> $GITHUB_OUTPUT
        echo "image-ref=${IMAGE_DEST}:${{ env.VERSION }}-${{ inputs.DATE_STAMP }}-${{ env.CLEAN_ARCH }}" >> $GITHUB_OUTPUT
        sudo podman inspect ${{ env.IMAGE_ID }}

    # NEW: Configure AWS credentials for KMS signing
    - name: Configure AWS credentials
      if: ${{ github.event_name != 'pull_request' && (env.res != 0 || github.event_name == 'workflow_dispatch') && inputs.AWS_ROLE_ARN != '' }}
      uses: aws-actions/configure-aws-credentials@v4
      with:
        role-to-assume: ${{ inputs.AWS_ROLE_ARN }}
        role-session-name: almalinux-bootc-signing-${{ github.run_id }}
        aws-region: ${{ inputs.AWS_REGION }}
        role-duration-seconds: 900  # 15 minutes

    - name: Install Cosign
      if: ${{ github.event_name != 'pull_request' && (env.res != 0 || github.event_name == 'workflow_dispatch') }}
      uses: sigstore/cosign-installer@3454372f43399081ed03b604cb2d021dabca52bb # v3.8.2
      with:
        install-dir: '/tmp/.cosign'

    # MODIFIED: Sign with KMS or fallback to legacy signing
    - name: Sign Image with KMS
      if: ${{ github.event_name != 'pull_request' && (env.res != 0 || github.event_name == 'workflow_dispatch') && inputs.AWS_ROLE_ARN != '' }}
      shell: bash
      env:
        KMS_KEY: awskms:///alias/${{ inputs.KMS_KEY_ID }}
        IMAGE_REF: ${{ steps.push.outputs.image-ref }}@${{ steps.push.outputs.digest }}
      run: |
        echo "Signing with KMS key: $KMS_KEY"

        # Sign the image
        sudo /tmp/.cosign/cosign sign --yes --key $KMS_KEY $IMAGE_REF

        # Add build attestation with provenance information
        BUILD_ATTESTATION=$(cat <<EOF
        {
          "buildType": "github-actions",
          "builder": {
            "id": "${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}"
          },
          "invocation": {
            "configSource": {
              "uri": "${{ github.server_url }}/${{ github.repository }}",
              "digest": {
                "sha1": "${{ github.sha }}"
              },
              "entryPoint": "${{ github.workflow }}"
            }
          },
          "metadata": {
            "buildInvocationId": "${{ github.run_id }}",
            "buildStartedOn": "$(date -u +%Y-%m-%dT%H:%M:%SZ)",
            "completeness": {
              "parameters": true,
              "environment": false,
              "materials": false
            },
            "reproducible": false
          },
          "materials": [
            {
              "uri": "${{ github.server_url }}/${{ github.repository }}",
              "digest": {
                "sha1": "${{ github.sha }}"
              }
            }
          ]
        }
        EOF
        )

        echo "$BUILD_ATTESTATION" > /tmp/build-attestation.json

        # Sign the attestation
        sudo /tmp/.cosign/cosign attest --yes --key $KMS_KEY \
          --predicate /tmp/build-attestation.json \
          $IMAGE_REF

        echo "Successfully signed image with KMS"

    # FALLBACK: Legacy signing method (if KMS not configured)
    - name: Sign Image (Legacy)
      if: ${{ github.event_name != 'pull_request' && (env.res != 0 || github.event_name == 'workflow_dispatch') && inputs.AWS_ROLE_ARN == '' && inputs.SIGNING_SECRET != '' }}
      shell: bash
      run: |
        echo "Using legacy signing method"
        echo "${{ inputs.SIGNING_SECRET }}" > /tmp/.cosign/cosign.key
        sudo /tmp/.cosign/cosign sign -y --key /tmp/.cosign/cosign.key ${{ steps.push.outputs.image-ref }}@${{ steps.push.outputs.digest }}

    # NEW: Verify the signature was created successfully
    - name: Verify Image Signature
      if: ${{ github.event_name != 'pull_request' && (env.res != 0 || github.event_name == 'workflow_dispatch') && inputs.AWS_ROLE_ARN != '' }}
      shell: bash
      env:
        KMS_KEY: awskms:///${{ inputs.KMS_KEY_ID }}
        IMAGE_REF: ${{ steps.push.outputs.image-ref }}@${{ steps.push.outputs.digest }}
      run: |
        echo "Verifying signature..."
        sudo /tmp/.cosign/cosign verify --key $KMS_KEY $IMAGE_REF
        echo "Signature verification successful"

    - name: Create Job Outputs
      if: ${{ env.res != 0 || github.event_name == 'workflow_dispatch' }}
      shell: bash
      run: |
        mkdir -p /tmp/outputs/digests

        jq -n --arg platform "${{ matrix.ARCH }}" \
          --arg major "${{ inputs.VERSION_MAJOR }}" \
          --arg digest "${{ steps.push.outputs.digest }}" \
          --arg id "${{ steps.run.outputs.id }}" \
          --arg version "${{ steps.run.outputs.version-id }}" \
          --arg long_version "${{ steps.run.outputs.long-version }}" \
          --arg vendor "${{ steps.run.outputs.vendor }}" \
          --arg image_id "${{ steps.rechunk.outputs.image-id }}" \
          '{($platform): {digest: $digest, id: $id, version: $version, major: $major, long_version: $long_version, vendor: $vendor, image_id: $image_id}}' \
          > /tmp/outputs/digests/${{ env.IMAGE_NAME }}_${{ matrix.VERSION_MAJOR }}_${{ env.CLEAN_ARCH }}.json

        cat /tmp/outputs/digests/${{ env.IMAGE_NAME }}_${{ matrix.VERSION_MAJOR }}_${{ env.CLEAN_ARCH }}.json

    - name: Upload Output Artifacts
      if: ${{ env.res != 0 || github.event_name == 'workflow_dispatch' }}
      uses: actions/upload-artifact@ea165f8d65b6e75b540449e92b4886f43607fa02 # v4
      with:
        name: ${{ env.IMAGE_NAME }}_${{ matrix.VERSION_MAJOR }}_${{ env.CLEAN_ARCH }}
        retention-days: 1
        if-no-files-found: error
        path: |
          /tmp/outputs/digests/*.json
